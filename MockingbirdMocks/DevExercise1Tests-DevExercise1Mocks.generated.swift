//
//  DevExercise1Tests-DevExercise1Mocks.generated.swift
//  DevExercise1
//
//  Generated by Mockingbird v0.14.0.
//  DO NOT EDIT
//

@testable import DevExercise1
@testable import Mockingbird
import ArcGIS
import CoreData
import Foundation
import LBTATools
import Moya
import Reachability
import Security
import Swift
import UIKit

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked AppDelegate

public final class AppDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'AppDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.AppDelegate.Type, file: StaticString = #file, line: UInt = #line) -> AppDelegateMock {
  fatalError()
}

// MARK: - Mocked CalloutMapperImpl

public final class CalloutMapperImplMock: DevExercise1.CalloutMapperImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `mapToCallout`(`feature`: [AGSArcGISFeature])

  public override func `mapToCallout`(`feature`: [AGSArcGISFeature]) throws -> DevExercise1.Callout { fatalError("See 'Thunk Stubs' in the README") }

  public func `mapToCallout`(`feature`: @escaping @autoclosure () -> [AGSArcGISFeature]) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, ([AGSArcGISFeature]) throws -> DevExercise1.Callout, DevExercise1.Callout> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CalloutMapperImpl`.
public func mock(_ type: DevExercise1.CalloutMapperImpl.Type, file: StaticString = #file, line: UInt = #line) -> CalloutMapperImplMock {
  return CalloutMapperImplMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CalloutMapper

public final class CalloutMapperMock: DevExercise1.CalloutMapper, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `mapToCallout`(`feature`: [AGSArcGISFeature])

  public func `mapToCallout`(`feature`: [AGSArcGISFeature]) throws -> DevExercise1.Callout { fatalError("See 'Thunk Stubs' in the README") }

  public func `mapToCallout`(`feature`: @escaping @autoclosure () -> [AGSArcGISFeature]) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, ([AGSArcGISFeature]) throws -> DevExercise1.Callout, DevExercise1.Callout> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CalloutMapper`.
public func mock(_ type: DevExercise1.CalloutMapper.Protocol, file: StaticString = #file, line: UInt = #line) -> CalloutMapperMock {
  return CalloutMapperMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryCasesViewModelInput

public final class CountryCasesViewModelInputMock: DevExercise1.CountryCasesViewModelInput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetchFromDataSource`(`forceRefresh`: Bool, `completion`: @escaping (Result<(), Error>) -> Void)

  public func `fetchFromDataSource`(`forceRefresh`: Bool, `completion`: @escaping (Result<(), Error>) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetchFromDataSource`(`forceRefresh`: @escaping @autoclosure () -> Bool, `completion`: @escaping @autoclosure () -> (Result<(), Error>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool, @escaping (Result<(), Error>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CountryCasesViewModelInput`.
public func mock(_ type: DevExercise1.CountryCasesViewModelInput.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryCasesViewModelInputMock {
  return CountryCasesViewModelInputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryCasesViewModelOutput

public final class CountryCasesViewModelOutputMock: DevExercise1.CountryCasesViewModelOutput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked countries

  public var `countries`: [DevExercise1.CountryItemModel] { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCountries() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [DevExercise1.CountryItemModel], [DevExercise1.CountryItemModel]> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `CountryCasesViewModelOutput`.
public func mock(_ type: DevExercise1.CountryCasesViewModelOutput.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryCasesViewModelOutputMock {
  return CountryCasesViewModelOutputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryCell

public final class CountryCellMock: DevExercise1.CountryCell, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> CountryCellMock? { fatalError("See 'Thunk Stubs' in the README") }

    public static func initialize(`style`: UITableViewCell.CellStyle, `reuseIdentifier`: String?, __file: StaticString = #file, __line: UInt = #line) -> CountryCellMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked point

  override public var `point`: AGSPoint? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getPoint() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSPoint?, AGSPoint?> { fatalError("See 'Thunk Stubs' in the README") }

  public func setPoint(_ newValue: @escaping @autoclosure () -> AGSPoint?) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (AGSPoint?) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `decideColor`(`caseNumber`: Int)

  public override func `decideColor`(`caseNumber`: Int) -> UIColor { fatalError("See 'Thunk Stubs' in the README") }

  public func `decideColor`(`caseNumber`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> UIColor, UIColor> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `set`(`country`: DevExercise1.Country)

  public override func `set`(`country`: DevExercise1.Country) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `set`(`country`: @escaping @autoclosure () -> DevExercise1.Country) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (DevExercise1.Country) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`style`: UITableViewCell.CellStyle, `reuseIdentifier`: String?)

  public required override init(`style`: UITableViewCell.CellStyle, `reuseIdentifier`: String?) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(CountryCell.self).initialize(…)`.
public func mock(_ type: DevExercise1.CountryCell.Type, file: StaticString = #file, line: UInt = #line) -> CountryCellMock.InitializerProxy.Type {
  return CountryCellMock.InitializerProxy.self
}

// MARK: - Mocked CountryController

public final class CountryControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'CountryController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.CountryController.Type, file: StaticString = #file, line: UInt = #line) -> CountryControllerMock {
  fatalError()
}

// MARK: - Mocked CountryMapperImpl

public final class CountryMapperImplMock: DevExercise1.CountryMapperImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `mapToCountry`(`features`: [AGSArcGISFeature])

  public override func `mapToCountry`(`features`: [AGSArcGISFeature]) -> Result<[DevExercise1.Country], Error> { fatalError("See 'Thunk Stubs' in the README") }

  public func `mapToCountry`(`features`: @escaping @autoclosure () -> [AGSArcGISFeature]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([AGSArcGISFeature]) -> Result<[DevExercise1.Country], Error>, Result<[DevExercise1.Country], Error>> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CountryMapperImpl`.
public func mock(_ type: DevExercise1.CountryMapperImpl.Type, file: StaticString = #file, line: UInt = #line) -> CountryMapperImplMock {
  return CountryMapperImplMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryMapper

public final class CountryMapperMock: DevExercise1.CountryMapper, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `mapToCountry`(`features`: [AGSArcGISFeature])

  public func `mapToCountry`(`features`: [AGSArcGISFeature]) -> Result<[DevExercise1.Country], Error> { fatalError("See 'Thunk Stubs' in the README") }

  public func `mapToCountry`(`features`: @escaping @autoclosure () -> [AGSArcGISFeature]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([AGSArcGISFeature]) -> Result<[DevExercise1.Country], Error>, Result<[DevExercise1.Country], Error>> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CountryMapper`.
public func mock(_ type: DevExercise1.CountryMapper.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryMapperMock {
  return CountryMapperMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryRemoteDataSourceImpl

public final class CountryRemoteDataSourceImplMock: DevExercise1.CountryRemoteDataSourceImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return self.stubbingContext.sourceLocation }
    set {
      self.stubbingContext.sourceLocation = newValue
      CountryRemoteDataSourceImplMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked dataRetrieved

  override public var `dataRetrieved`: [AGSArcGISFeature] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "dataRetrieved.get", arguments: [], returnType: Swift.ObjectIdentifier(([AGSArcGISFeature]).self))
      return self.mockingContext.didInvoke(invocation) { () -> [AGSArcGISFeature] in
        let implementation = self.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> [AGSArcGISFeature] {
          return concreteImplementation()
        } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: ([AGSArcGISFeature]).self) {
          return defaultValue
        } else {
          fatalError(self.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "dataRetrieved.set", arguments: [ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))
      self.mockingContext.didInvoke(invocation)
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([AGSArcGISFeature]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getDataRetrieved() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "dataRetrieved.get", arguments: [], returnType: Swift.ObjectIdentifier(([AGSArcGISFeature]).self))
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]>(mock: self, invocation: invocation)
  }

  public func setDataRetrieved(_ newValue: @escaping @autoclosure () -> [AGSArcGISFeature]) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, ([AGSArcGISFeature]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "dataRetrieved.set", arguments: arguments, returnType: Swift.ObjectIdentifier(Void.self))
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, ([AGSArcGISFeature]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked featureTable

  override public var `featureTable`: AGSServiceFeatureTable {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "featureTable.get", arguments: [], returnType: Swift.ObjectIdentifier((AGSServiceFeatureTable).self))
      return self.mockingContext.didInvoke(invocation) { () -> AGSServiceFeatureTable in
        let implementation = self.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> AGSServiceFeatureTable {
          return concreteImplementation()
        } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: (AGSServiceFeatureTable).self) {
          return defaultValue
        } else {
          fatalError(self.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "featureTable.set", arguments: [ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))
      self.mockingContext.didInvoke(invocation)
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (AGSServiceFeatureTable) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getFeatureTable() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSServiceFeatureTable, AGSServiceFeatureTable> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "featureTable.get", arguments: [], returnType: Swift.ObjectIdentifier((AGSServiceFeatureTable).self))
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSServiceFeatureTable, AGSServiceFeatureTable>(mock: self, invocation: invocation)
  }

  public func setFeatureTable(_ newValue: @escaping @autoclosure () -> AGSServiceFeatureTable) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (AGSServiceFeatureTable) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "featureTable.set", arguments: arguments, returnType: Swift.ObjectIdentifier(Void.self))
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (AGSServiceFeatureTable) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void)

  public override func `fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void", arguments: [Mockingbird.ArgumentMatcher(`completion`)], returnType: Swift.ObjectIdentifier((Void).self))
    self.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void {
        concreteImplementation(`completion`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `fetch`(`completion`: @escaping @autoclosure () -> (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`completion`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void", arguments: arguments, returnType: Swift.ObjectIdentifier((Void).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `retrieveCountries`()

  public override func `retrieveCountries`() -> [AGSArcGISFeature] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`retrieveCountries`() -> [AGSArcGISFeature]", arguments: [], returnType: Swift.ObjectIdentifier(([AGSArcGISFeature]).self))
    return self.mockingContext.didInvoke(invocation) { () -> [AGSArcGISFeature] in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> [AGSArcGISFeature] {
        return concreteImplementation()
      } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: ([AGSArcGISFeature]).self) {
        return defaultValue
      } else {
        fatalError(self.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `retrieveCountries`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`retrieveCountries`() -> [AGSArcGISFeature]", arguments: [], returnType: Swift.ObjectIdentifier(([AGSArcGISFeature]).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]>(mock: self, invocation: invocation)
  }
}

/// Returns a concrete mock of `CountryRemoteDataSourceImpl`.
public func mock(_ type: DevExercise1.CountryRemoteDataSourceImpl.Type, file: StaticString = #file, line: UInt = #line) -> CountryRemoteDataSourceImplMock {
  return CountryRemoteDataSourceImplMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryRemoteDataSource

public final class CountryRemoteDataSourceMock: DevExercise1.CountryRemoteDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked featureTable

  public var `featureTable`: AGSServiceFeatureTable { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getFeatureTable() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSServiceFeatureTable, AGSServiceFeatureTable> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void)

  public func `fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`(`completion`: @escaping @autoclosure () -> (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `retrieveCountries`()

  public func `retrieveCountries`() -> [AGSArcGISFeature] { fatalError("See 'Thunk Stubs' in the README") }

  public func `retrieveCountries`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CountryRemoteDataSource`.
public func mock(_ type: DevExercise1.CountryRemoteDataSource.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryRemoteDataSourceMock {
  return CountryRemoteDataSourceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryRepositoryImpl

public final class CountryRepositoryImplMock: DevExercise1.CountryRepositoryImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`remoteDataSource`: DevExercise1.CountryRemoteDataSource, `internetConnection`: DevExercise1.ReachabilityObserverDelegate, __file: StaticString = #file, __line: UInt = #line) -> CountryRepositoryImplMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked `fetch`(`forceRefresh`: Bool, `completion`: @escaping (Result<[AGSArcGISFeature], Error>) -> Void)

  public override func `fetch`(`forceRefresh`: Bool, `completion`: @escaping (Result<[AGSArcGISFeature], Error>) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`(`forceRefresh`: @escaping @autoclosure () -> Bool, `completion`: @escaping @autoclosure () -> (Result<[AGSArcGISFeature], Error>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool, @escaping (Result<[AGSArcGISFeature], Error>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`remoteDataSource`: DevExercise1.CountryRemoteDataSource, `internetConnection`: DevExercise1.ReachabilityObserverDelegate)

  public required override init(`remoteDataSource`: DevExercise1.CountryRemoteDataSource, `internetConnection`: DevExercise1.ReachabilityObserverDelegate) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(CountryRepositoryImpl.self).initialize(…)`.
public func mock(_ type: DevExercise1.CountryRepositoryImpl.Type, file: StaticString = #file, line: UInt = #line) -> CountryRepositoryImplMock.InitializerProxy.Type {
  return CountryRepositoryImplMock.InitializerProxy.self
}

// MARK: - Mocked CountryRepository

public final class CountryRepositoryMock: DevExercise1.CountryRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`(`forceRefresh`: Bool, `completion`: @escaping (Result<[AGSArcGISFeature], Error>) -> Void)

  public func `fetch`(`forceRefresh`: Bool, `completion`: @escaping (Result<[AGSArcGISFeature], Error>) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`(`forceRefresh`: @escaping @autoclosure () -> Bool, `completion`: @escaping @autoclosure () -> (Result<[AGSArcGISFeature], Error>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool, @escaping (Result<[AGSArcGISFeature], Error>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CountryRepository`.
public func mock(_ type: DevExercise1.CountryRepository.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryRepositoryMock {
  return CountryRepositoryMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked InternetConnectivity

public final class InternetConnectivityMock: DevExercise1.InternetConnectivity, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> InternetConnectivityMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked connectionStatus

  override public var `connectionStatus`: Bool { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getConnectionStatus() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Bool, Bool> { fatalError("See 'Thunk Stubs' in the README") }

  public func setConnectionStatus(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (Bool) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init()

  public required init() { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `reachabilityChanged`(_ `isReachable`: Bool)

  public override func `reachabilityChanged`(_ `isReachable`: Bool) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `reachabilityChanged`(_ `isReachable`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(InternetConnectivity.self).initialize(…)`.
public func mock(_ type: DevExercise1.InternetConnectivity.Type, file: StaticString = #file, line: UInt = #line) -> InternetConnectivityMock.InitializerProxy.Type {
  return InternetConnectivityMock.InitializerProxy.self
}

// MARK: - Mocked LoginViewController

public final class LoginViewControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'LoginViewController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.LoginViewController.Type, file: StaticString = #file, line: UInt = #line) -> LoginViewControllerMock {
  fatalError()
}

// MARK: - Mocked MainTabController

public final class MainTabControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'MainTabController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.MainTabController.Type, file: StaticString = #file, line: UInt = #line) -> MainTabControllerMock {
  fatalError()
}

// MARK: - Mocked MapRemoteDataSource

public final class MapRemoteDataSourceMock: DevExercise1.MapRemoteDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `MapRemoteDataSource`.
public func mock(_ type: DevExercise1.MapRemoteDataSource.Type, file: StaticString = #file, line: UInt = #line) -> MapRemoteDataSourceMock {
  return MapRemoteDataSourceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked MapRepositoryImpl

public final class MapRepositoryImplMock: DevExercise1.MapRepositoryImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`remoteDataSource`: DevExercise1.MapRemoteDataSource, __file: StaticString = #file, __line: UInt = #line) -> MapRepositoryImplMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked init(`remoteDataSource`: DevExercise1.MapRemoteDataSource)

  public required override init(`remoteDataSource`: DevExercise1.MapRemoteDataSource) { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `fetch`()

  public override func `fetch`() -> [AGSFeatureLayer] { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [AGSFeatureLayer], [AGSFeatureLayer]> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(MapRepositoryImpl.self).initialize(…)`.
public func mock(_ type: DevExercise1.MapRepositoryImpl.Type, file: StaticString = #file, line: UInt = #line) -> MapRepositoryImplMock.InitializerProxy.Type {
  return MapRepositoryImplMock.InitializerProxy.self
}

// MARK: - Mocked MapRepository

public final class MapRepositoryMock: DevExercise1.MapRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`()

  public func `fetch`() -> [AGSFeatureLayer] { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [AGSFeatureLayer], [AGSFeatureLayer]> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `MapRepository`.
public func mock(_ type: DevExercise1.MapRepository.Protocol, file: StaticString = #file, line: UInt = #line) -> MapRepositoryMock {
  return MapRepositoryMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked MapViewController

public final class MapViewControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'MapViewController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.MapViewController.Type, file: StaticString = #file, line: UInt = #line) -> MapViewControllerMock {
  fatalError()
}

// MARK: - Mocked MapViewModelInput

public final class MapViewModelInputMock: DevExercise1.MapViewModelInput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `licenseMap`()

  public func `licenseMap`() throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `licenseMap`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `MapViewModelInput`.
public func mock(_ type: DevExercise1.MapViewModelInput.Protocol, file: StaticString = #file, line: UInt = #line) -> MapViewModelInputMock {
  return MapViewModelInputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked MapViewModel

public final class MapViewModelMock: DevExercise1.MapViewModel, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`repository`: DevExercise1.MapRepository, __file: StaticString = #file, __line: UInt = #line) -> MapViewModelMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked `licenseMap`()

  public override func `licenseMap`() throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `licenseMap`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `retrieveFeatureLayers`(`completion`: @escaping ([AGSFeatureLayer]) -> Void)

  public override func `retrieveFeatureLayers`(`completion`: @escaping ([AGSFeatureLayer]) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `retrieveFeatureLayers`(`completion`: @escaping @autoclosure () -> ([AGSFeatureLayer]) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping ([AGSFeatureLayer]) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`repository`: DevExercise1.MapRepository)

  public required override init(`repository`: DevExercise1.MapRepository) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(MapViewModel.self).initialize(…)`.
public func mock(_ type: DevExercise1.MapViewModel.Type, file: StaticString = #file, line: UInt = #line) -> MapViewModelMock.InitializerProxy.Type {
  return MapViewModelMock.InitializerProxy.self
}

// MARK: - Mocked ReachabilityActionDelegate

public final class ReachabilityActionDelegateMock: DevExercise1.ReachabilityActionDelegate, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `reachabilityChanged`(_ `isReachable`: Bool)

  public func `reachabilityChanged`(_ `isReachable`: Bool) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `reachabilityChanged`(_ `isReachable`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `ReachabilityActionDelegate`.
public func mock(_ type: DevExercise1.ReachabilityActionDelegate.Protocol, file: StaticString = #file, line: UInt = #line) -> ReachabilityActionDelegateMock {
  return ReachabilityActionDelegateMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ReachabilityObserverDelegate

public final class ReachabilityObserverDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'ReachabilityObserverDelegate' inherits from the externally-defined type 'class' which needs to be declared in a supporting source file")
public func mock(_ type: DevExercise1.ReachabilityObserverDelegate.Protocol, file: StaticString = #file, line: UInt = #line) -> ReachabilityObserverDelegateMock {
  fatalError()
}

// MARK: - Mocked SceneDelegate

public final class SceneDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'SceneDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.SceneDelegate.Type, file: StaticString = #file, line: UInt = #line) -> SceneDelegateMock {
  fatalError()
}

// MARK: - Mocked SecureDataStorage

public final class SecureDataStorageMock: DevExercise1.SecureDataStorage, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`service`: String, __file: StaticString = #file, __line: UInt = #line) -> SecureDataStorageMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked `contains`(`item`: DevExercise1.SecureDataItem)

  public override func `contains`(`item`: DevExercise1.SecureDataItem) -> Bool { fatalError("See 'Thunk Stubs' in the README") }

  public func `contains`(`item`: @escaping @autoclosure () -> DevExercise1.SecureDataItem) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (DevExercise1.SecureDataItem) -> Bool, Bool> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `retrieve`(`item`: DevExercise1.SecureDataItem)

  public override func `retrieve`(`item`: DevExercise1.SecureDataItem) throws -> String { fatalError("See 'Thunk Stubs' in the README") }

  public func `retrieve`(`item`: @escaping @autoclosure () -> DevExercise1.SecureDataItem) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (DevExercise1.SecureDataItem) throws -> String, String> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `removeAllData`()

  public override func `removeAllData`() throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `removeAllData`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `delete`(_ `items`: DevExercise1.SecureDataItem...)

  public override func `delete`(_ `items`: DevExercise1.SecureDataItem...) throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `delete`(_ `items`: @escaping @autoclosure () -> [DevExercise1.SecureDataItem]) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, ([DevExercise1.SecureDataItem]) throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  public func `delete`(_ `items`: DevExercise1.SecureDataItem...) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, ([DevExercise1.SecureDataItem]) throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`service`: String)

  public required override init(`service`: String) { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `store`(`value`: String, `item`: DevExercise1.SecureDataItem)

  public override func `store`(`value`: String, `item`: DevExercise1.SecureDataItem) throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `store`(`value`: @escaping @autoclosure () -> String, `item`: @escaping @autoclosure () -> DevExercise1.SecureDataItem) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (String, DevExercise1.SecureDataItem) throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(SecureDataStorage.self).initialize(…)`.
public func mock(_ type: DevExercise1.SecureDataStorage.Type, file: StaticString = #file, line: UInt = #line) -> SecureDataStorageMock.InitializerProxy.Type {
  return SecureDataStorageMock.InitializerProxy.self
}

// MARK: - Mocked SecureStorage

public final class SecureStorageMock: DevExercise1.SecureStorage, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `contains`(`item`: DevExercise1.SecureDataItem)

  public func `contains`(`item`: DevExercise1.SecureDataItem) -> Bool { fatalError("See 'Thunk Stubs' in the README") }

  public func `contains`(`item`: @escaping @autoclosure () -> DevExercise1.SecureDataItem) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (DevExercise1.SecureDataItem) -> Bool, Bool> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `retrieve`(`item`: DevExercise1.SecureDataItem)

  public func `retrieve`(`item`: DevExercise1.SecureDataItem) throws -> String { fatalError("See 'Thunk Stubs' in the README") }

  public func `retrieve`(`item`: @escaping @autoclosure () -> DevExercise1.SecureDataItem) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (DevExercise1.SecureDataItem) throws -> String, String> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `removeAllData`()

  public func `removeAllData`() throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `removeAllData`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `delete`(_ `items`: DevExercise1.SecureDataItem...)

  public func `delete`(_ `items`: DevExercise1.SecureDataItem...) throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `delete`(_ `items`: @escaping @autoclosure () -> [DevExercise1.SecureDataItem]) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, ([DevExercise1.SecureDataItem]) throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  public func `delete`(_ `items`: DevExercise1.SecureDataItem...) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, ([DevExercise1.SecureDataItem]) throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `store`(`value`: String, `item`: DevExercise1.SecureDataItem)

  public func `store`(`value`: String, `item`: DevExercise1.SecureDataItem) throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `store`(`value`: @escaping @autoclosure () -> String, `item`: @escaping @autoclosure () -> DevExercise1.SecureDataItem) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (String, DevExercise1.SecureDataItem) throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `SecureStorage`.
public func mock(_ type: DevExercise1.SecureStorage.Protocol, file: StaticString = #file, line: UInt = #line) -> SecureStorageMock {
  return SecureStorageMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked SecureStoreQueryable

public final class SecureStoreQueryableMock: DevExercise1.SecureStoreQueryable, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked query

  public var `query`: [String: Any] { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getQuery() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [String: Any], [String: Any]> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `SecureStoreQueryable`.
public func mock(_ type: DevExercise1.SecureStoreQueryable.Protocol, file: StaticString = #file, line: UInt = #line) -> SecureStoreQueryableMock {
  return SecureStoreQueryableMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked SignOutController

public final class SignOutControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'SignOutController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.SignOutController.Type, file: StaticString = #file, line: UInt = #line) -> SignOutControllerMock {
  fatalError()
}

// MARK: - Mocked SignOutUseCase

public final class SignOutUseCaseMock: DevExercise1.SignOutUseCase, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `signOut`(`completion`: @escaping (Result<(), Error>) -> Void)

  public func `signOut`(`completion`: @escaping (Result<(), Error>) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `signOut`(`completion`: @escaping @autoclosure () -> (Result<(), Error>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Result<(), Error>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `SignOutUseCase`.
public func mock(_ type: DevExercise1.SignOutUseCase.Protocol, file: StaticString = #file, line: UInt = #line) -> SignOutUseCaseMock {
  return SignOutUseCaseMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked UserLocalDataSourceImpl

public final class UserLocalDataSourceImplMock: DevExercise1.UserLocalDataSourceImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`secure`: DevExercise1.SecureStorage, __file: StaticString = #file, __line: UInt = #line) -> UserLocalDataSourceImplMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked authenticatedUser

  override public var `authenticatedUser`: String? { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getAuthenticatedUser() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String?, String?> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked authenticationToken

  override public var `authenticationToken`: String? { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getAuthenticationToken() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String?, String?> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `savedUser`()

  public override func `savedUser`() throws -> DevExercise1.User? { fatalError("See 'Thunk Stubs' in the README") }

  public func `savedUser`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> DevExercise1.User?, DevExercise1.User?> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `removeAllData`()

  public override func `removeAllData`() throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `removeAllData`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `signOutWithRememberMe`()

  public override func `signOutWithRememberMe`() throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `signOutWithRememberMe`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`secure`: DevExercise1.SecureStorage)

  public required override init(`secure`: DevExercise1.SecureStorage) { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `rememberUser`(`username`: String, `password`: String, `token`: String)

  public override func `rememberUser`(`username`: String, `password`: String, `token`: String) throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `rememberUser`(`username`: @escaping @autoclosure () -> String, `password`: @escaping @autoclosure () -> String, `token`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (String, String, String) throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(UserLocalDataSourceImpl.self).initialize(…)`.
public func mock(_ type: DevExercise1.UserLocalDataSourceImpl.Type, file: StaticString = #file, line: UInt = #line) -> UserLocalDataSourceImplMock.InitializerProxy.Type {
  return UserLocalDataSourceImplMock.InitializerProxy.self
}

// MARK: - Mocked UserLocalDataSource

public final class UserLocalDataSourceMock: DevExercise1.UserLocalDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked authenticatedUser

  public var `authenticatedUser`: String? { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getAuthenticatedUser() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String?, String?> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked authenticationToken

  public var `authenticationToken`: String? { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getAuthenticationToken() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String?, String?> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `savedUser`()

  public func `savedUser`() throws -> DevExercise1.User? { fatalError("See 'Thunk Stubs' in the README") }

  public func `savedUser`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> DevExercise1.User?, DevExercise1.User?> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `removeAllData`()

  public func `removeAllData`() throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `removeAllData`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `signOutWithRememberMe`()

  public func `signOutWithRememberMe`() throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `signOutWithRememberMe`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `rememberUser`(`username`: String, `password`: String, `token`: String)

  public func `rememberUser`(`username`: String, `password`: String, `token`: String) throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `rememberUser`(`username`: @escaping @autoclosure () -> String, `password`: @escaping @autoclosure () -> String, `token`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (String, String, String) throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `UserLocalDataSource`.
public func mock(_ type: DevExercise1.UserLocalDataSource.Protocol, file: StaticString = #file, line: UInt = #line) -> UserLocalDataSourceMock {
  return UserLocalDataSourceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked UserRemoteDataSourceImpl

public final class UserRemoteDataSourceImplMock: DevExercise1.UserRemoteDataSourceImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> UserRemoteDataSourceImplMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked init()

  public required override init() { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `logOut`(`completion`: @escaping (Result<(), Error>) -> Void)

  public override func `logOut`(`completion`: @escaping (Result<(), Error>) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `logOut`(`completion`: @escaping @autoclosure () -> (Result<(), Error>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Result<(), Error>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `arcGISSignIn`(`credential`: AGSCredential, `completion`: @escaping (Result<AGSCredential, Error>) -> Void)

  public override func `arcGISSignIn`(`credential`: AGSCredential, `completion`: @escaping (Result<AGSCredential, Error>) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `arcGISSignIn`(`credential`: @escaping @autoclosure () -> AGSCredential, `completion`: @escaping @autoclosure () -> (Result<AGSCredential, Error>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (AGSCredential, @escaping (Result<AGSCredential, Error>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(UserRemoteDataSourceImpl.self).initialize(…)`.
public func mock(_ type: DevExercise1.UserRemoteDataSourceImpl.Type, file: StaticString = #file, line: UInt = #line) -> UserRemoteDataSourceImplMock.InitializerProxy.Type {
  return UserRemoteDataSourceImplMock.InitializerProxy.self
}

// MARK: - Mocked UserRemoteDataSource

public final class UserRemoteDataSourceMock: DevExercise1.UserRemoteDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `logOut`(`completion`: @escaping (Result<(), Error>) -> Void)

  public func `logOut`(`completion`: @escaping (Result<(), Error>) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `logOut`(`completion`: @escaping @autoclosure () -> (Result<(), Error>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Result<(), Error>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `arcGISSignIn`(`credential`: AGSCredential, `completion`: @escaping (Result<AGSCredential, Error>) -> Void)

  public func `arcGISSignIn`(`credential`: AGSCredential, `completion`: @escaping (Result<AGSCredential, Error>) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `arcGISSignIn`(`credential`: @escaping @autoclosure () -> AGSCredential, `completion`: @escaping @autoclosure () -> (Result<AGSCredential, Error>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (AGSCredential, @escaping (Result<AGSCredential, Error>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `UserRemoteDataSource`.
public func mock(_ type: DevExercise1.UserRemoteDataSource.Protocol, file: StaticString = #file, line: UInt = #line) -> UserRemoteDataSourceMock {
  return UserRemoteDataSourceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked UserTimeout

public final class UserTimeoutMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'UserTimeout' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.UserTimeout.Type, file: StaticString = #file, line: UInt = #line) -> UserTimeoutMock {
  fatalError()
}

// MARK: - Mocked onClickedPointDelegate

public final class onClickedPointDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'onClickedPointDelegate' inherits from the externally-defined type 'class' which needs to be declared in a supporting source file")
public func mock(_ type: DevExercise1.onClickedPointDelegate.Protocol, file: StaticString = #file, line: UInt = #line) -> onClickedPointDelegateMock {
  fatalError()
}
