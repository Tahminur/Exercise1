//
//  DevExercise1Tests-DevExercise1Mocks.generated.swift
//  DevExercise1
//
//  Generated by Mockingbird v0.14.0.
//  DO NOT EDIT
//

@testable import DevExercise1
@testable import Mockingbird
import ArcGIS
import CoreData
import Foundation
import Network
import Swift
import UIKit

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked AppDelegate

public final class AppDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'AppDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.AppDelegate.Type, file: StaticString = #file, line: UInt = #line) -> AppDelegateMock {
  fatalError()
}

// MARK: - Mocked CountryCasesRemoteDataSource

public final class CountryCasesRemoteDataSourceMock: DevExercise1.CountryCasesRemoteDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return self.stubbingContext.sourceLocation }
    set {
      self.stubbingContext.sourceLocation = newValue
      CountryCasesRemoteDataSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked DataRetrieved

  override public var `DataRetrieved`: [DevExercise1.Country] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "DataRetrieved.get", arguments: [], returnType: Swift.ObjectIdentifier(([DevExercise1.Country]).self))
      return self.mockingContext.didInvoke(invocation) { () -> [DevExercise1.Country] in
        let implementation = self.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> [DevExercise1.Country] {
          return concreteImplementation()
        } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: ([DevExercise1.Country]).self) {
          return defaultValue
        } else {
          fatalError(self.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "DataRetrieved.set", arguments: [ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))
      self.mockingContext.didInvoke(invocation)
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([DevExercise1.Country]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getDataRetrieved() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [DevExercise1.Country], [DevExercise1.Country]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "DataRetrieved.get", arguments: [], returnType: Swift.ObjectIdentifier(([DevExercise1.Country]).self))
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [DevExercise1.Country], [DevExercise1.Country]>(mock: self, invocation: invocation)
  }

  public func setDataRetrieved(_ newValue: @escaping @autoclosure () -> [DevExercise1.Country]) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, ([DevExercise1.Country]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "DataRetrieved.set", arguments: arguments, returnType: Swift.ObjectIdentifier(Void.self))
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, ([DevExercise1.Country]) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`(`completion`: @escaping () -> Void)

  public override func `fetch`(`completion`: @escaping () -> Void) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fetch`(`completion`: @escaping () -> Void) -> Void", arguments: [Mockingbird.ArgumentMatcher(`completion`)], returnType: Swift.ObjectIdentifier((Void).self))
    self.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@escaping () -> Void) -> Void {
        concreteImplementation(`completion`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `fetch`(`completion`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping () -> Void) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`completion`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fetch`(`completion`: @escaping () -> Void) -> Void", arguments: arguments, returnType: Swift.ObjectIdentifier((Void).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping () -> Void) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `retrieveCountries`()

  public override func `retrieveCountries`() -> [DevExercise1.Country] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`retrieveCountries`() -> [DevExercise1.Country]", arguments: [], returnType: Swift.ObjectIdentifier(([DevExercise1.Country]).self))
    return self.mockingContext.didInvoke(invocation) { () -> [DevExercise1.Country] in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> [DevExercise1.Country] {
        return concreteImplementation()
      } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: ([DevExercise1.Country]).self) {
        return defaultValue
      } else {
        fatalError(self.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `retrieveCountries`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [DevExercise1.Country], [DevExercise1.Country]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`retrieveCountries`() -> [DevExercise1.Country]", arguments: [], returnType: Swift.ObjectIdentifier(([DevExercise1.Country]).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [DevExercise1.Country], [DevExercise1.Country]>(mock: self, invocation: invocation)
  }
}

/// Returns a concrete mock of `CountryCasesRemoteDataSource`.
public func mock(_ type: DevExercise1.CountryCasesRemoteDataSource.Type, file: StaticString = #file, line: UInt = #line) -> CountryCasesRemoteDataSourceMock {
  return CountryCasesRemoteDataSourceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryCasesViewModelInput

public final class CountryCasesViewModelInputMock: DevExercise1.CountryCasesViewModelInput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetchFromDataSource`(`forceRefresh`: Bool, `completion`: @escaping (String?) -> Void)

  public func `fetchFromDataSource`(`forceRefresh`: Bool, `completion`: @escaping (String?) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetchFromDataSource`(`forceRefresh`: @escaping @autoclosure () -> Bool, `completion`: @escaping @autoclosure () -> (String?) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool, @escaping (String?) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CountryCasesViewModelInput`.
public func mock(_ type: DevExercise1.CountryCasesViewModelInput.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryCasesViewModelInputMock {
  return CountryCasesViewModelInputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryCasesViewModelOutput

public final class CountryCasesViewModelOutputMock: DevExercise1.CountryCasesViewModelOutput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked Countries

  public var `Countries`: [DevExercise1.CountryItemViewModel] { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCountries() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [DevExercise1.CountryItemViewModel], [DevExercise1.CountryItemViewModel]> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `CountryCasesViewModelOutput`.
public func mock(_ type: DevExercise1.CountryCasesViewModelOutput.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryCasesViewModelOutputMock {
  return CountryCasesViewModelOutputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryCell

public final class CountryCellMock: DevExercise1.CountryCell, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> CountryCellMock? { fatalError("See 'Thunk Stubs' in the README") }

    public static func initialize(`style`: UITableViewCell.CellStyle, `reuseIdentifier`: String?, __file: StaticString = #file, __line: UInt = #line) -> CountryCellMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked point

  override public var `point`: AGSPoint { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getPoint() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSPoint, AGSPoint> { fatalError("See 'Thunk Stubs' in the README") }

  public func setPoint(_ newValue: @escaping @autoclosure () -> AGSPoint) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (AGSPoint) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `set`(`country`: DevExercise1.Country)

  public override func `set`(`country`: DevExercise1.Country) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `set`(`country`: @escaping @autoclosure () -> DevExercise1.Country) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (DevExercise1.Country) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`style`: UITableViewCell.CellStyle, `reuseIdentifier`: String?)

  public required override init(`style`: UITableViewCell.CellStyle, `reuseIdentifier`: String?) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(CountryCell.self).initialize(…)`.
public func mock(_ type: DevExercise1.CountryCell.Type, file: StaticString = #file, line: UInt = #line) -> CountryCellMock.InitializerProxy.Type {
  return CountryCellMock.InitializerProxy.self
}

// MARK: - Mocked CountryController

public final class CountryControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'CountryController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.CountryController.Type, file: StaticString = #file, line: UInt = #line) -> CountryControllerMock {
  fatalError()
}

// MARK: - Mocked CountryDataRepository

public final class CountryDataRepositoryMock: DevExercise1.CountryDataRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`remoteDataSource`: DevExercise1.CountryCasesRemoteDataSource, __file: StaticString = #file, __line: UInt = #line) -> CountryDataRepositoryMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked `fetch`(`forceRefresh`: Bool, `completion`: @escaping () -> Void)

  public override func `fetch`(`forceRefresh`: Bool, `completion`: @escaping () -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`(`forceRefresh`: @escaping @autoclosure () -> Bool, `completion`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool, @escaping () -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`remoteDataSource`: DevExercise1.CountryCasesRemoteDataSource)

  public required override init(`remoteDataSource`: DevExercise1.CountryCasesRemoteDataSource) { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `retrieveCountries`()

  public override func `retrieveCountries`() -> [DevExercise1.Country] { fatalError("See 'Thunk Stubs' in the README") }

  public func `retrieveCountries`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [DevExercise1.Country], [DevExercise1.Country]> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(CountryDataRepository.self).initialize(…)`.
public func mock(_ type: DevExercise1.CountryDataRepository.Type, file: StaticString = #file, line: UInt = #line) -> CountryDataRepositoryMock.InitializerProxy.Type {
  return CountryDataRepositoryMock.InitializerProxy.self
}

// MARK: - Mocked CountryItemViewModelOutput

public final class CountryItemViewModelOutputMock: DevExercise1.CountryItemViewModelOutput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked countryCases

  public var `countryCases`: Int { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCountryCases() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Int, Int> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked countryName

  public var `countryName`: String { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCountryName() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked countryPoint

  public var `countryPoint`: AGSPoint { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCountryPoint() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSPoint, AGSPoint> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `CountryItemViewModelOutput`.
public func mock(_ type: DevExercise1.CountryItemViewModelOutput.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryItemViewModelOutputMock {
  return CountryItemViewModelOutputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryMapper

public final class CountryMapperMock: DevExercise1.CountryMapper, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `mapToCountry`(`features`: [AGSArcGISFeature])

  public override func `mapToCountry`(`features`: [AGSArcGISFeature]) -> [DevExercise1.Country] { fatalError("See 'Thunk Stubs' in the README") }

  public func `mapToCountry`(`features`: @escaping @autoclosure () -> [AGSArcGISFeature]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([AGSArcGISFeature]) -> [DevExercise1.Country], [DevExercise1.Country]> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CountryMapper`.
public func mock(_ type: DevExercise1.CountryMapper.Type, file: StaticString = #file, line: UInt = #line) -> CountryMapperMock {
  return CountryMapperMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked InternetConnection

public final class InternetConnectionMock: DevExercise1.InternetConnection, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> InternetConnectionMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked status

  override public var `status`: String? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getStatus() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String?, String?> { fatalError("See 'Thunk Stubs' in the README") }

  public func setStatus(_ newValue: @escaping @autoclosure () -> String?) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (String?) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init()

  public required override init() { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(InternetConnection.self).initialize(…)`.
public func mock(_ type: DevExercise1.InternetConnection.Type, file: StaticString = #file, line: UInt = #line) -> InternetConnectionMock.InitializerProxy.Type {
  return InternetConnectionMock.InitializerProxy.self
}

// MARK: - Mocked MainTabController

public final class MainTabControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'MainTabController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.MainTabController.Type, file: StaticString = #file, line: UInt = #line) -> MainTabControllerMock {
  fatalError()
}

// MARK: - Mocked MapViewController

public final class MapViewControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'MapViewController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.MapViewController.Type, file: StaticString = #file, line: UInt = #line) -> MapViewControllerMock {
  fatalError()
}

// MARK: - Mocked MapViewModelInput

public final class MapViewModelInputMock: DevExercise1.MapViewModelInput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked featureURLs

  public var `featureURLs`: [String] { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getFeatureURLs() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [String], [String]> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked map

  public var `map`: AGSMap { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getMap() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSMap, AGSMap> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `LicenseMap`()

  public func `LicenseMap`() throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `LicenseMap`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `addFeaturesToMap`()

  public func `addFeaturesToMap`() -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `addFeaturesToMap`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `authenticateMap`(`completion`: @escaping (String?) -> Void)

  public func `authenticateMap`(`completion`: @escaping (String?) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `authenticateMap`(`completion`: @escaping @autoclosure () -> (String?) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (String?) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `MapViewModelInput`.
public func mock(_ type: DevExercise1.MapViewModelInput.Protocol, file: StaticString = #file, line: UInt = #line) -> MapViewModelInputMock {
  return MapViewModelInputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked MapViewModel

public final class MapViewModelMock: DevExercise1.MapViewModel, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`map`: AGSMap, `featureURLs`: [String], __file: StaticString = #file, __line: UInt = #line) -> MapViewModelMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked featureTables

  override public var `featureTables`: [AGSServiceFeatureTable] { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getFeatureTables() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [AGSServiceFeatureTable], [AGSServiceFeatureTable]> { fatalError("See 'Thunk Stubs' in the README") }

  public func setFeatureTables(_ newValue: @escaping @autoclosure () -> [AGSServiceFeatureTable]) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, ([AGSServiceFeatureTable]) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked featureURLs

  override public var `featureURLs`: [String] { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getFeatureURLs() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [String], [String]> { fatalError("See 'Thunk Stubs' in the README") }

  public func setFeatureURLs(_ newValue: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, ([String]) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked map

  override public var `map`: AGSMap { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getMap() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSMap, AGSMap> { fatalError("See 'Thunk Stubs' in the README") }

  public func setMap(_ newValue: @escaping @autoclosure () -> AGSMap) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (AGSMap) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked point

  override public var `point`: AGSPoint { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getPoint() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSPoint, AGSPoint> { fatalError("See 'Thunk Stubs' in the README") }

  public func setPoint(_ newValue: @escaping @autoclosure () -> AGSPoint) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (AGSPoint) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `LicenseMap`()

  public override func `LicenseMap`() throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `LicenseMap`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `addFeaturesToMap`()

  public override func `addFeaturesToMap`() -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `addFeaturesToMap`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `authenticateMap`(`completion`: @escaping (String?) -> Void)

  public override func `authenticateMap`(`completion`: @escaping (String?) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `authenticateMap`(`completion`: @escaping @autoclosure () -> (String?) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (String?) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`map`: AGSMap, `featureURLs`: [String])

  public required override init(`map`: AGSMap, `featureURLs`: [String]) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(MapViewModel.self).initialize(…)`.
public func mock(_ type: DevExercise1.MapViewModel.Type, file: StaticString = #file, line: UInt = #line) -> MapViewModelMock.InitializerProxy.Type {
  return MapViewModelMock.InitializerProxy.self
}

// MARK: - Mocked RemoteDataSource

public final class RemoteDataSourceMock: DevExercise1.RemoteDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked FeatureTable

  public var `FeatureTable`: AGSServiceFeatureTable { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getFeatureTable() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSServiceFeatureTable, AGSServiceFeatureTable> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`(`completion`: @escaping () -> Void)

  public func `fetch`(`completion`: @escaping () -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`(`completion`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping () -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `RemoteDataSource`.
public func mock(_ type: DevExercise1.RemoteDataSource.Protocol, file: StaticString = #file, line: UInt = #line) -> RemoteDataSourceMock {
  return RemoteDataSourceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked Repositories

public final class RepositoriesMock: DevExercise1.Repositories, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`(`forceRefresh`: Bool, `completion`: @escaping () -> Void)

  public func `fetch`(`forceRefresh`: Bool, `completion`: @escaping () -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`(`forceRefresh`: @escaping @autoclosure () -> Bool, `completion`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool, @escaping () -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `Repositories`.
public func mock(_ type: DevExercise1.Repositories.Protocol, file: StaticString = #file, line: UInt = #line) -> RepositoriesMock {
  return RepositoriesMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked SceneDelegate

public final class SceneDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'SceneDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.SceneDelegate.Type, file: StaticString = #file, line: UInt = #line) -> SceneDelegateMock {
  fatalError()
}

// MARK: - Mocked Util

public final class UtilMock: DevExercise1.Util, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `convertFeatureToCountry`(`feature`: AGSArcGISFeature)

  public override func `convertFeatureToCountry`(`feature`: AGSArcGISFeature) -> DevExercise1.Country { fatalError("See 'Thunk Stubs' in the README") }

  public func `convertFeatureToCountry`(`feature`: @escaping @autoclosure () -> AGSArcGISFeature) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (AGSArcGISFeature) -> DevExercise1.Country, DevExercise1.Country> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `decideColor`(`caseNumber`: Int)

  public override func `decideColor`(`caseNumber`: Int) -> UIColor { fatalError("See 'Thunk Stubs' in the README") }

  public func `decideColor`(`caseNumber`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> UIColor, UIColor> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `Util`.
public func mock(_ type: DevExercise1.Util.Type, file: StaticString = #file, line: UInt = #line) -> UtilMock {
  return UtilMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}
