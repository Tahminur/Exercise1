//
//  DevExercise1Tests-DevExercise1Mocks.generated.swift
//  DevExercise1
//
//  Generated by Mockingbird v0.14.0.
//  DO NOT EDIT
//

@testable import DevExercise1
@testable import Mockingbird
import ArcGIS
import CoreData
import Foundation
import Swift
import SystemConfiguration
import UIKit

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked AppDelegate

public final class AppDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'AppDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.AppDelegate.Type, file: StaticString = #file, line: UInt = #line) -> AppDelegateMock {
  fatalError()
}

// MARK: - Mocked ArcGISAuthenticationManager

public final class ArcGISAuthenticationManagerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'ArcGISAuthenticationManager' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.ArcGISAuthenticationManager.Type, file: StaticString = #file, line: UInt = #line) -> ArcGISAuthenticationManagerMock {
  fatalError()
}

// MARK: - Mocked CountryCasesRemoteDataSource

public final class CountryCasesRemoteDataSourceMock: DevExercise1.CountryCasesRemoteDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return self.stubbingContext.sourceLocation }
    set {
      self.stubbingContext.sourceLocation = newValue
      CountryCasesRemoteDataSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked dataRetrieved

  override public var `dataRetrieved`: [AGSArcGISFeature] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "dataRetrieved.get", arguments: [], returnType: Swift.ObjectIdentifier(([AGSArcGISFeature]).self))
      return self.mockingContext.didInvoke(invocation) { () -> [AGSArcGISFeature] in
        let implementation = self.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> [AGSArcGISFeature] {
          return concreteImplementation()
        } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: ([AGSArcGISFeature]).self) {
          return defaultValue
        } else {
          fatalError(self.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "dataRetrieved.set", arguments: [ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))
      self.mockingContext.didInvoke(invocation)
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([AGSArcGISFeature]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getDataRetrieved() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "dataRetrieved.get", arguments: [], returnType: Swift.ObjectIdentifier(([AGSArcGISFeature]).self))
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]>(mock: self, invocation: invocation)
  }

  public func setDataRetrieved(_ newValue: @escaping @autoclosure () -> [AGSArcGISFeature]) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, ([AGSArcGISFeature]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "dataRetrieved.set", arguments: arguments, returnType: Swift.ObjectIdentifier(Void.self))
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, ([AGSArcGISFeature]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked featureTable

  override public var `featureTable`: AGSServiceFeatureTable {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "featureTable.get", arguments: [], returnType: Swift.ObjectIdentifier((AGSServiceFeatureTable).self))
      return self.mockingContext.didInvoke(invocation) { () -> AGSServiceFeatureTable in
        let implementation = self.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> AGSServiceFeatureTable {
          return concreteImplementation()
        } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: (AGSServiceFeatureTable).self) {
          return defaultValue
        } else {
          fatalError(self.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "featureTable.set", arguments: [ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))
      self.mockingContext.didInvoke(invocation)
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (AGSServiceFeatureTable) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getFeatureTable() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSServiceFeatureTable, AGSServiceFeatureTable> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "featureTable.get", arguments: [], returnType: Swift.ObjectIdentifier((AGSServiceFeatureTable).self))
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSServiceFeatureTable, AGSServiceFeatureTable>(mock: self, invocation: invocation)
  }

  public func setFeatureTable(_ newValue: @escaping @autoclosure () -> AGSServiceFeatureTable) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (AGSServiceFeatureTable) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "featureTable.set", arguments: arguments, returnType: Swift.ObjectIdentifier(Void.self))
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (AGSServiceFeatureTable) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void)

  public override func `fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void", arguments: [Mockingbird.ArgumentMatcher(`completion`)], returnType: Swift.ObjectIdentifier((Void).self))
    self.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void {
        concreteImplementation(`completion`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `fetch`(`completion`: @escaping @autoclosure () -> (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`completion`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void", arguments: arguments, returnType: Swift.ObjectIdentifier((Void).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `retrieveCountries`()

  public override func `retrieveCountries`() -> [AGSArcGISFeature] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`retrieveCountries`() -> [AGSArcGISFeature]", arguments: [], returnType: Swift.ObjectIdentifier(([AGSArcGISFeature]).self))
    return self.mockingContext.didInvoke(invocation) { () -> [AGSArcGISFeature] in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> [AGSArcGISFeature] {
        return concreteImplementation()
      } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: ([AGSArcGISFeature]).self) {
        return defaultValue
      } else {
        fatalError(self.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `retrieveCountries`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`retrieveCountries`() -> [AGSArcGISFeature]", arguments: [], returnType: Swift.ObjectIdentifier(([AGSArcGISFeature]).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]>(mock: self, invocation: invocation)
  }
}

/// Returns a concrete mock of `CountryCasesRemoteDataSource`.
public func mock(_ type: DevExercise1.CountryCasesRemoteDataSource.Type, file: StaticString = #file, line: UInt = #line) -> CountryCasesRemoteDataSourceMock {
  return CountryCasesRemoteDataSourceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryCasesViewModelInput

public final class CountryCasesViewModelInputMock: DevExercise1.CountryCasesViewModelInput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetchFromDataSource`(`forceRefresh`: Bool, `completion`: @escaping (String?) -> Void)

  public func `fetchFromDataSource`(`forceRefresh`: Bool, `completion`: @escaping (String?) -> Void) { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetchFromDataSource`(`forceRefresh`: @escaping @autoclosure () -> Bool, `completion`: @escaping @autoclosure () -> (String?) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool, @escaping (String?) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CountryCasesViewModelInput`.
public func mock(_ type: DevExercise1.CountryCasesViewModelInput.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryCasesViewModelInputMock {
  return CountryCasesViewModelInputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryCasesViewModelOutput

public final class CountryCasesViewModelOutputMock: DevExercise1.CountryCasesViewModelOutput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked countries

  public var `countries`: [DevExercise1.CountryItemViewModel] { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCountries() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [DevExercise1.CountryItemViewModel], [DevExercise1.CountryItemViewModel]> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `CountryCasesViewModelOutput`.
public func mock(_ type: DevExercise1.CountryCasesViewModelOutput.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryCasesViewModelOutputMock {
  return CountryCasesViewModelOutputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryCell

public final class CountryCellMock: DevExercise1.CountryCell, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> CountryCellMock? { fatalError("See 'Thunk Stubs' in the README") }

    public static func initialize(`style`: UITableViewCell.CellStyle, `reuseIdentifier`: String?, __file: StaticString = #file, __line: UInt = #line) -> CountryCellMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked point

  override public var `point`: AGSPoint? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getPoint() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSPoint?, AGSPoint?> { fatalError("See 'Thunk Stubs' in the README") }

  public func setPoint(_ newValue: @escaping @autoclosure () -> AGSPoint?) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (AGSPoint?) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `decideColor`(`caseNumber`: Int)

  public override func `decideColor`(`caseNumber`: Int) -> UIColor { fatalError("See 'Thunk Stubs' in the README") }

  public func `decideColor`(`caseNumber`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> UIColor, UIColor> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `set`(`country`: DevExercise1.Country)

  public override func `set`(`country`: DevExercise1.Country) { fatalError("See 'Thunk Stubs' in the README") }

  public func `set`(`country`: @escaping @autoclosure () -> DevExercise1.Country) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (DevExercise1.Country) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`style`: UITableViewCell.CellStyle, `reuseIdentifier`: String?)

  public required override init(`style`: UITableViewCell.CellStyle, `reuseIdentifier`: String?) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(CountryCell.self).initialize(…)`.
public func mock(_ type: DevExercise1.CountryCell.Type, file: StaticString = #file, line: UInt = #line) -> CountryCellMock.InitializerProxy.Type {
  return CountryCellMock.InitializerProxy.self
}

// MARK: - Mocked CountryControllerFactory

public final class CountryControllerFactoryMock: DevExercise1.CountryControllerFactory, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `CountryControllerFactory`.
public func mock(_ type: DevExercise1.CountryControllerFactory.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryControllerFactoryMock {
  return CountryControllerFactoryMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryController

public final class CountryControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'CountryController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.CountryController.Type, file: StaticString = #file, line: UInt = #line) -> CountryControllerMock {
  fatalError()
}

// MARK: - Mocked CountryDataRepository

public final class CountryDataRepositoryMock: DevExercise1.CountryDataRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`remoteDataSource`: DevExercise1.CountryCasesRemoteDataSource, `reachable`: @escaping DevExercise1.Reachable, __file: StaticString = #file, __line: UInt = #line) -> CountryDataRepositoryMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked `fetch`(`forceRefresh`: Bool, `completion`: @escaping (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void)

  public override func `fetch`(`forceRefresh`: Bool, `completion`: @escaping (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void) { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`(`forceRefresh`: @escaping @autoclosure () -> Bool, `completion`: @escaping @autoclosure () -> (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool, @escaping (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`remoteDataSource`: DevExercise1.CountryCasesRemoteDataSource, `reachable`: @escaping DevExercise1.Reachable)

  public required override init(`remoteDataSource`: DevExercise1.CountryCasesRemoteDataSource, `reachable`: @escaping DevExercise1.Reachable) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(CountryDataRepository.self).initialize(…)`.
public func mock(_ type: DevExercise1.CountryDataRepository.Type, file: StaticString = #file, line: UInt = #line) -> CountryDataRepositoryMock.InitializerProxy.Type {
  return CountryDataRepositoryMock.InitializerProxy.self
}

// MARK: - Mocked CountryItemViewModelOutput

public final class CountryItemViewModelOutputMock: DevExercise1.CountryItemViewModelOutput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked countryCases

  public var `countryCases`: Int { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCountryCases() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Int, Int> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked countryName

  public var `countryName`: String { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCountryName() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked countryPoint

  public var `countryPoint`: AGSPoint? { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCountryPoint() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSPoint?, AGSPoint?> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `CountryItemViewModelOutput`.
public func mock(_ type: DevExercise1.CountryItemViewModelOutput.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryItemViewModelOutputMock {
  return CountryItemViewModelOutputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryMapper

public final class CountryMapperMock: DevExercise1.CountryMapper, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `mapToCountry`(`features`: [AGSArcGISFeature])

  public override func `mapToCountry`(`features`: [AGSArcGISFeature]) -> [DevExercise1.Country] { fatalError("See 'Thunk Stubs' in the README") }

  public func `mapToCountry`(`features`: @escaping @autoclosure () -> [AGSArcGISFeature]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([AGSArcGISFeature]) -> [DevExercise1.Country], [DevExercise1.Country]> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CountryMapper`.
public func mock(_ type: DevExercise1.CountryMapper.Type, file: StaticString = #file, line: UInt = #line) -> CountryMapperMock {
  return CountryMapperMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked MainTabController

public final class MainTabControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'MainTabController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.MainTabController.Type, file: StaticString = #file, line: UInt = #line) -> MainTabControllerMock {
  fatalError()
}

// MARK: - Mocked MapControllerFactory

public final class MapControllerFactoryMock: DevExercise1.MapControllerFactory, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `MapControllerFactory`.
public func mock(_ type: DevExercise1.MapControllerFactory.Protocol, file: StaticString = #file, line: UInt = #line) -> MapControllerFactoryMock {
  return MapControllerFactoryMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked MapManager

public final class MapManagerMock: DevExercise1.MapManager, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> MapManagerMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked init()

  public required override init() { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(MapManager.self).initialize(…)`.
public func mock(_ type: DevExercise1.MapManager.Type, file: StaticString = #file, line: UInt = #line) -> MapManagerMock.InitializerProxy.Type {
  return MapManagerMock.InitializerProxy.self
}

// MARK: - Mocked MapRemoteDataSource

public final class MapRemoteDataSourceMock: DevExercise1.MapRemoteDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `MapRemoteDataSource`.
public func mock(_ type: DevExercise1.MapRemoteDataSource.Type, file: StaticString = #file, line: UInt = #line) -> MapRemoteDataSourceMock {
  return MapRemoteDataSourceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked MapRepository

public final class MapRepositoryMock: DevExercise1.MapRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`remoteDataSource`: DevExercise1.MapRemoteDataSource, __file: StaticString = #file, __line: UInt = #line) -> MapRepositoryMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked init(`remoteDataSource`: DevExercise1.MapRemoteDataSource)

  public required override init(`remoteDataSource`: DevExercise1.MapRemoteDataSource) { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `fetch`()

  public override func `fetch`() -> [AGSFeatureLayer] { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [AGSFeatureLayer], [AGSFeatureLayer]> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(MapRepository.self).initialize(…)`.
public func mock(_ type: DevExercise1.MapRepository.Type, file: StaticString = #file, line: UInt = #line) -> MapRepositoryMock.InitializerProxy.Type {
  return MapRepositoryMock.InitializerProxy.self
}

// MARK: - Mocked MapViewController

public final class MapViewControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'MapViewController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.MapViewController.Type, file: StaticString = #file, line: UInt = #line) -> MapViewControllerMock {
  fatalError()
}

// MARK: - Mocked MapViewModelInput

public final class MapViewModelInputMock: DevExercise1.MapViewModelInput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `licenseMap`()

  public func `licenseMap`() throws { fatalError("See 'Thunk Stubs' in the README") }

  public func `licenseMap`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `MapViewModelInput`.
public func mock(_ type: DevExercise1.MapViewModelInput.Protocol, file: StaticString = #file, line: UInt = #line) -> MapViewModelInputMock {
  return MapViewModelInputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked MapViewModel

public final class MapViewModelMock: DevExercise1.MapViewModel, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`repository`: DevExercise1.MapRepository, __file: StaticString = #file, __line: UInt = #line) -> MapViewModelMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked `licenseMap`()

  public override func `licenseMap`() throws { fatalError("See 'Thunk Stubs' in the README") }

  public func `licenseMap`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `retrieveFeatureLayers`(`completion`: @escaping ([AGSFeatureLayer]) -> Void)

  public override func `retrieveFeatureLayers`(`completion`: @escaping ([AGSFeatureLayer]) -> Void) { fatalError("See 'Thunk Stubs' in the README") }

  public func `retrieveFeatureLayers`(`completion`: @escaping @autoclosure () -> ([AGSFeatureLayer]) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping ([AGSFeatureLayer]) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`repository`: DevExercise1.MapRepository)

  public required override init(`repository`: DevExercise1.MapRepository) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(MapViewModel.self).initialize(…)`.
public func mock(_ type: DevExercise1.MapViewModel.Type, file: StaticString = #file, line: UInt = #line) -> MapViewModelMock.InitializerProxy.Type {
  return MapViewModelMock.InitializerProxy.self
}

// MARK: - Mocked Reachability

public final class ReachabilityMock: DevExercise1.Reachability, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`reachabilityRef`: SCNetworkReachability, __file: StaticString = #file, __line: UInt = #line) -> ReachabilityMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked currentReachabilityStatus

  override public var `currentReachabilityStatus`: DevExercise1.Reachability.NetworkStatus { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCurrentReachabilityStatus() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> DevExercise1.Reachability.NetworkStatus, DevExercise1.Reachability.NetworkStatus> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked currentReachabilityString

  override public var `currentReachabilityString`: String { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCurrentReachabilityString() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked reachableOnWWAN

  override public var `reachableOnWWAN`: Bool { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getReachableOnWWAN() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Bool, Bool> { fatalError("See 'Thunk Stubs' in the README") }

  public func setReachableOnWWAN(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (Bool) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked whenReachable

  override public var `whenReachable`: ReachabilityMock.NetworkReachable? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getWhenReachable() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> ReachabilityMock.NetworkReachable?, ReachabilityMock.NetworkReachable?> { fatalError("See 'Thunk Stubs' in the README") }

  public func setWhenReachable(_ newValue: @escaping @autoclosure () -> ReachabilityMock.NetworkReachable?) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (ReachabilityMock.NetworkReachable?) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked whenUnreachable

  override public var `whenUnreachable`: ReachabilityMock.NetworkUnreachable? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getWhenUnreachable() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> ReachabilityMock.NetworkUnreachable?, ReachabilityMock.NetworkUnreachable?> { fatalError("See 'Thunk Stubs' in the README") }

  public func setWhenUnreachable(_ newValue: @escaping @autoclosure () -> ReachabilityMock.NetworkUnreachable?) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (ReachabilityMock.NetworkUnreachable?) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`reachabilityRef`: SCNetworkReachability)

  public required init(`reachabilityRef`: SCNetworkReachability) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(Reachability.self).initialize(…)`.
public func mock(_ type: DevExercise1.Reachability.Type, file: StaticString = #file, line: UInt = #line) -> ReachabilityMock.InitializerProxy.Type {
  return ReachabilityMock.InitializerProxy.self
}

// MARK: - Mocked RemoteDataSource

public final class RemoteDataSourceMock: DevExercise1.RemoteDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked featureTable

  public var `featureTable`: AGSServiceFeatureTable { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getFeatureTable() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSServiceFeatureTable, AGSServiceFeatureTable> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void)

  public func `fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`(`completion`: @escaping @autoclosure () -> (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `RemoteDataSource`.
public func mock(_ type: DevExercise1.RemoteDataSource.Protocol, file: StaticString = #file, line: UInt = #line) -> RemoteDataSourceMock {
  return RemoteDataSourceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked Repositories

public final class RepositoriesMock: DevExercise1.Repositories, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`(`forceRefresh`: Bool, `completion`: @escaping (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void)

  public func `fetch`(`forceRefresh`: Bool, `completion`: @escaping (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void) { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`(`forceRefresh`: @escaping @autoclosure () -> Bool, `completion`: @escaping @autoclosure () -> (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool, @escaping (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `Repositories`.
public func mock(_ type: DevExercise1.Repositories.Protocol, file: StaticString = #file, line: UInt = #line) -> RepositoriesMock {
  return RepositoriesMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked SceneDelegate

public final class SceneDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'SceneDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.SceneDelegate.Type, file: StaticString = #file, line: UInt = #line) -> SceneDelegateMock {
  fatalError()
}
