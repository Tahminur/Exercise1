//
//  DevExercise1Tests-DevExercise1Mocks.generated.swift
//  DevExercise1
//
//  Generated by Mockingbird v0.14.0.
//  DO NOT EDIT
//

@testable import DevExercise1
@testable import Mockingbird
import ArcGIS
import CoreData
import Foundation
import Moya
import Swift
import SystemConfiguration
import UIKit

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked AppDelegate

public final class AppDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'AppDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.AppDelegate.Type, file: StaticString = #file, line: UInt = #line) -> AppDelegateMock {
  fatalError()
}

// MARK: - Mocked ArcGISAuthenticationManager

public final class ArcGISAuthenticationManagerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'ArcGISAuthenticationManager' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.ArcGISAuthenticationManager.Type, file: StaticString = #file, line: UInt = #line) -> ArcGISAuthenticationManagerMock {
  fatalError()
}

// MARK: - Mocked CalloutMapperImpl

public final class CalloutMapperImplMock: DevExercise1.CalloutMapperImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `mapToCallout`(`feature`: [AGSArcGISFeature])

  public override func `mapToCallout`(`feature`: [AGSArcGISFeature]) throws -> DevExercise1.Callout { fatalError("See 'Thunk Stubs' in the README") }

  public func `mapToCallout`(`feature`: @escaping @autoclosure () -> [AGSArcGISFeature]) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, ([AGSArcGISFeature]) throws -> DevExercise1.Callout, DevExercise1.Callout> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CalloutMapperImpl`.
public func mock(_ type: DevExercise1.CalloutMapperImpl.Type, file: StaticString = #file, line: UInt = #line) -> CalloutMapperImplMock {
  return CalloutMapperImplMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CalloutMapper

public final class CalloutMapperMock: DevExercise1.CalloutMapper, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `mapToCallout`(`feature`: [AGSArcGISFeature])

  public func `mapToCallout`(`feature`: [AGSArcGISFeature]) throws -> DevExercise1.Callout { fatalError("See 'Thunk Stubs' in the README") }

  public func `mapToCallout`(`feature`: @escaping @autoclosure () -> [AGSArcGISFeature]) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, ([AGSArcGISFeature]) throws -> DevExercise1.Callout, DevExercise1.Callout> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CalloutMapper`.
public func mock(_ type: DevExercise1.CalloutMapper.Protocol, file: StaticString = #file, line: UInt = #line) -> CalloutMapperMock {
  return CalloutMapperMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryCasesViewModelInput

public final class CountryCasesViewModelInputMock: DevExercise1.CountryCasesViewModelInput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetchFromDataSource`(`forceRefresh`: Bool, `completion`: @escaping (String?) -> Void)

  public func `fetchFromDataSource`(`forceRefresh`: Bool, `completion`: @escaping (String?) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetchFromDataSource`(`forceRefresh`: @escaping @autoclosure () -> Bool, `completion`: @escaping @autoclosure () -> (String?) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool, @escaping (String?) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CountryCasesViewModelInput`.
public func mock(_ type: DevExercise1.CountryCasesViewModelInput.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryCasesViewModelInputMock {
  return CountryCasesViewModelInputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryCasesViewModelOutput

public final class CountryCasesViewModelOutputMock: DevExercise1.CountryCasesViewModelOutput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked countries

  public var `countries`: [DevExercise1.CountryItemViewModel] { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCountries() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [DevExercise1.CountryItemViewModel], [DevExercise1.CountryItemViewModel]> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `CountryCasesViewModelOutput`.
public func mock(_ type: DevExercise1.CountryCasesViewModelOutput.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryCasesViewModelOutputMock {
  return CountryCasesViewModelOutputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryCell

public final class CountryCellMock: DevExercise1.CountryCell, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> CountryCellMock? { fatalError("See 'Thunk Stubs' in the README") }

    public static func initialize(`style`: UITableViewCell.CellStyle, `reuseIdentifier`: String?, __file: StaticString = #file, __line: UInt = #line) -> CountryCellMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked point

  override public var `point`: AGSPoint? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getPoint() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSPoint?, AGSPoint?> { fatalError("See 'Thunk Stubs' in the README") }

  public func setPoint(_ newValue: @escaping @autoclosure () -> AGSPoint?) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (AGSPoint?) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `decideColor`(`caseNumber`: Int)

  public override func `decideColor`(`caseNumber`: Int) -> UIColor { fatalError("See 'Thunk Stubs' in the README") }

  public func `decideColor`(`caseNumber`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> UIColor, UIColor> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `set`(`country`: DevExercise1.Country)

  public override func `set`(`country`: DevExercise1.Country) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `set`(`country`: @escaping @autoclosure () -> DevExercise1.Country) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (DevExercise1.Country) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`style`: UITableViewCell.CellStyle, `reuseIdentifier`: String?)

  public required override init(`style`: UITableViewCell.CellStyle, `reuseIdentifier`: String?) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(CountryCell.self).initialize(…)`.
public func mock(_ type: DevExercise1.CountryCell.Type, file: StaticString = #file, line: UInt = #line) -> CountryCellMock.InitializerProxy.Type {
  return CountryCellMock.InitializerProxy.self
}

// MARK: - Mocked CountryController

public final class CountryControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'CountryController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.CountryController.Type, file: StaticString = #file, line: UInt = #line) -> CountryControllerMock {
  fatalError()
}

// MARK: - Mocked CountryItemViewModelOutput

public final class CountryItemViewModelOutputMock: DevExercise1.CountryItemViewModelOutput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked countryCases

  public var `countryCases`: Int { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCountryCases() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Int, Int> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked countryName

  public var `countryName`: String { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCountryName() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked countryPoint

  public var `countryPoint`: AGSPoint? { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCountryPoint() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSPoint?, AGSPoint?> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `CountryItemViewModelOutput`.
public func mock(_ type: DevExercise1.CountryItemViewModelOutput.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryItemViewModelOutputMock {
  return CountryItemViewModelOutputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryMapperImpl

public final class CountryMapperImplMock: DevExercise1.CountryMapperImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `mapToCountry`(`features`: [AGSArcGISFeature])

  public override func `mapToCountry`(`features`: [AGSArcGISFeature]) -> [DevExercise1.Country] { fatalError("See 'Thunk Stubs' in the README") }

  public func `mapToCountry`(`features`: @escaping @autoclosure () -> [AGSArcGISFeature]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([AGSArcGISFeature]) -> [DevExercise1.Country], [DevExercise1.Country]> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CountryMapperImpl`.
public func mock(_ type: DevExercise1.CountryMapperImpl.Type, file: StaticString = #file, line: UInt = #line) -> CountryMapperImplMock {
  return CountryMapperImplMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryMapper

public final class CountryMapperMock: DevExercise1.CountryMapper, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return self.stubbingContext.sourceLocation }
    set {
      self.stubbingContext.sourceLocation = newValue
      CountryMapperMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `mapToCountry`(`features`: [AGSArcGISFeature])

  public func `mapToCountry`(`features`: [AGSArcGISFeature]) -> [DevExercise1.Country] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`mapToCountry`(`features`: [AGSArcGISFeature]) -> [DevExercise1.Country]", arguments: [Mockingbird.ArgumentMatcher(`features`)], returnType: Swift.ObjectIdentifier(([DevExercise1.Country]).self))
    return self.mockingContext.didInvoke(invocation) { () -> [DevExercise1.Country] in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([AGSArcGISFeature]) -> [DevExercise1.Country] {
        return concreteImplementation(`features`)
      } else if let concreteImplementation = implementation as? () -> [DevExercise1.Country] {
        return concreteImplementation()
      } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: ([DevExercise1.Country]).self) {
        return defaultValue
      } else {
        fatalError(self.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `mapToCountry`(`features`: @escaping @autoclosure () -> [AGSArcGISFeature]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([AGSArcGISFeature]) -> [DevExercise1.Country], [DevExercise1.Country]> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`features`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`mapToCountry`(`features`: [AGSArcGISFeature]) -> [DevExercise1.Country]", arguments: arguments, returnType: Swift.ObjectIdentifier(([DevExercise1.Country]).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([AGSArcGISFeature]) -> [DevExercise1.Country], [DevExercise1.Country]>(mock: self, invocation: invocation)
  }
}

/// Returns a concrete mock of `CountryMapper`.
public func mock(_ type: DevExercise1.CountryMapper.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryMapperMock {
  return CountryMapperMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryRemoteDataSourceImpl

public final class CountryRemoteDataSourceImplMock: DevExercise1.CountryRemoteDataSourceImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return self.stubbingContext.sourceLocation }
    set {
      self.stubbingContext.sourceLocation = newValue
      CountryRemoteDataSourceImplMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked dataRetrieved

  override public var `dataRetrieved`: [AGSArcGISFeature] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "dataRetrieved.get", arguments: [], returnType: Swift.ObjectIdentifier(([AGSArcGISFeature]).self))
      return self.mockingContext.didInvoke(invocation) { () -> [AGSArcGISFeature] in
        let implementation = self.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> [AGSArcGISFeature] {
          return concreteImplementation()
        } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: ([AGSArcGISFeature]).self) {
          return defaultValue
        } else {
          fatalError(self.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "dataRetrieved.set", arguments: [ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))
      self.mockingContext.didInvoke(invocation)
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([AGSArcGISFeature]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getDataRetrieved() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "dataRetrieved.get", arguments: [], returnType: Swift.ObjectIdentifier(([AGSArcGISFeature]).self))
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]>(mock: self, invocation: invocation)
  }

  public func setDataRetrieved(_ newValue: @escaping @autoclosure () -> [AGSArcGISFeature]) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, ([AGSArcGISFeature]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "dataRetrieved.set", arguments: arguments, returnType: Swift.ObjectIdentifier(Void.self))
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, ([AGSArcGISFeature]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked featureTable

  override public var `featureTable`: AGSServiceFeatureTable {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "featureTable.get", arguments: [], returnType: Swift.ObjectIdentifier((AGSServiceFeatureTable).self))
      return self.mockingContext.didInvoke(invocation) { () -> AGSServiceFeatureTable in
        let implementation = self.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> AGSServiceFeatureTable {
          return concreteImplementation()
        } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: (AGSServiceFeatureTable).self) {
          return defaultValue
        } else {
          fatalError(self.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "featureTable.set", arguments: [ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))
      self.mockingContext.didInvoke(invocation)
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (AGSServiceFeatureTable) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getFeatureTable() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSServiceFeatureTable, AGSServiceFeatureTable> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "featureTable.get", arguments: [], returnType: Swift.ObjectIdentifier((AGSServiceFeatureTable).self))
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSServiceFeatureTable, AGSServiceFeatureTable>(mock: self, invocation: invocation)
  }

  public func setFeatureTable(_ newValue: @escaping @autoclosure () -> AGSServiceFeatureTable) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (AGSServiceFeatureTable) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "featureTable.set", arguments: arguments, returnType: Swift.ObjectIdentifier(Void.self))
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (AGSServiceFeatureTable) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void)

  public override func `fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void", arguments: [Mockingbird.ArgumentMatcher(`completion`)], returnType: Swift.ObjectIdentifier((Void).self))
    self.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void {
        concreteImplementation(`completion`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `fetch`(`completion`: @escaping @autoclosure () -> (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`completion`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void", arguments: arguments, returnType: Swift.ObjectIdentifier((Void).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `retrieveCountries`()

  public override func `retrieveCountries`() -> [AGSArcGISFeature] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`retrieveCountries`() -> [AGSArcGISFeature]", arguments: [], returnType: Swift.ObjectIdentifier(([AGSArcGISFeature]).self))
    return self.mockingContext.didInvoke(invocation) { () -> [AGSArcGISFeature] in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> [AGSArcGISFeature] {
        return concreteImplementation()
      } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: ([AGSArcGISFeature]).self) {
        return defaultValue
      } else {
        fatalError(self.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `retrieveCountries`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`retrieveCountries`() -> [AGSArcGISFeature]", arguments: [], returnType: Swift.ObjectIdentifier(([AGSArcGISFeature]).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]>(mock: self, invocation: invocation)
  }
}

/// Returns a concrete mock of `CountryRemoteDataSourceImpl`.
public func mock(_ type: DevExercise1.CountryRemoteDataSourceImpl.Type, file: StaticString = #file, line: UInt = #line) -> CountryRemoteDataSourceImplMock {
  return CountryRemoteDataSourceImplMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryRemoteDataSource

public final class CountryRemoteDataSourceMock: DevExercise1.CountryRemoteDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  // MARK: Mocked featureTable

  public var `featureTable`: AGSServiceFeatureTable { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getFeatureTable() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AGSServiceFeatureTable, AGSServiceFeatureTable> { fatalError("See 'Thunk Stubs' in the README") }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void)

  public func `fetch`(`completion`: @escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`(`completion`: @escaping @autoclosure () -> (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Result<[AGSArcGISFeature], DevExercise1.fetchError>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `retrieveCountries`()

  public func `retrieveCountries`() -> [AGSArcGISFeature] { fatalError("See 'Thunk Stubs' in the README") }

  public func `retrieveCountries`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [AGSArcGISFeature], [AGSArcGISFeature]> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CountryRemoteDataSource`.
public func mock(_ type: DevExercise1.CountryRemoteDataSource.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryRemoteDataSourceMock {
  return CountryRemoteDataSourceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CountryRepositoryImpl

public final class CountryRepositoryImplMock: DevExercise1.CountryRepositoryImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`remoteDataSource`: DevExercise1.CountryRemoteDataSource, `mapper`: DevExercise1.CountryMapper, `reachable`: @escaping DevExercise1.Reachable, __file: StaticString = #file, __line: UInt = #line) -> CountryRepositoryImplMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked `fetch`(`forceRefresh`: Bool, `completion`: @escaping (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void)

  public override func `fetch`(`forceRefresh`: Bool, `completion`: @escaping (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`(`forceRefresh`: @escaping @autoclosure () -> Bool, `completion`: @escaping @autoclosure () -> (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool, @escaping (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`remoteDataSource`: DevExercise1.CountryRemoteDataSource, `mapper`: DevExercise1.CountryMapper, `reachable`: @escaping DevExercise1.Reachable)

  public required override init(`remoteDataSource`: DevExercise1.CountryRemoteDataSource, `mapper`: DevExercise1.CountryMapper, `reachable`: @escaping DevExercise1.Reachable) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(CountryRepositoryImpl.self).initialize(…)`.
public func mock(_ type: DevExercise1.CountryRepositoryImpl.Type, file: StaticString = #file, line: UInt = #line) -> CountryRepositoryImplMock.InitializerProxy.Type {
  return CountryRepositoryImplMock.InitializerProxy.self
}

// MARK: - Mocked CountryRepository

public final class CountryRepositoryMock: DevExercise1.CountryRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`(`forceRefresh`: Bool, `completion`: @escaping (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void)

  public func `fetch`(`forceRefresh`: Bool, `completion`: @escaping (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`(`forceRefresh`: @escaping @autoclosure () -> Bool, `completion`: @escaping @autoclosure () -> (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool, @escaping (Result<[DevExercise1.Country], DevExercise1.fetchError>) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `CountryRepository`.
public func mock(_ type: DevExercise1.CountryRepository.Protocol, file: StaticString = #file, line: UInt = #line) -> CountryRepositoryMock {
  return CountryRepositoryMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked LoginViewController

public final class LoginViewControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'LoginViewController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.LoginViewController.Type, file: StaticString = #file, line: UInt = #line) -> LoginViewControllerMock {
  fatalError()
}

// MARK: - Mocked Login

public final class LoginMock: DevExercise1.Login, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `rememberMe`()

  public func `rememberMe`() -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `rememberMe`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `login`(`username`: String, `password`: String)

  public func `login`(`username`: String, `password`: String) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `login`(`username`: @escaping @autoclosure () -> String, `password`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, String) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `Login`.
public func mock(_ type: DevExercise1.Login.Protocol, file: StaticString = #file, line: UInt = #line) -> LoginMock {
  return LoginMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked MainTabController

public final class MainTabControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'MainTabController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.MainTabController.Type, file: StaticString = #file, line: UInt = #line) -> MainTabControllerMock {
  fatalError()
}

// MARK: - Mocked MapManager

public final class MapManagerMock: DevExercise1.MapManager, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> MapManagerMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked init()

  public required override init() { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(MapManager.self).initialize(…)`.
public func mock(_ type: DevExercise1.MapManager.Type, file: StaticString = #file, line: UInt = #line) -> MapManagerMock.InitializerProxy.Type {
  return MapManagerMock.InitializerProxy.self
}

// MARK: - Mocked MapRemoteDataSource

public final class MapRemoteDataSourceMock: DevExercise1.MapRemoteDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `MapRemoteDataSource`.
public func mock(_ type: DevExercise1.MapRemoteDataSource.Type, file: StaticString = #file, line: UInt = #line) -> MapRemoteDataSourceMock {
  return MapRemoteDataSourceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked MapRepositoryImpl

public final class MapRepositoryImplMock: DevExercise1.MapRepositoryImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`remoteDataSource`: DevExercise1.MapRemoteDataSource, __file: StaticString = #file, __line: UInt = #line) -> MapRepositoryImplMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked init(`remoteDataSource`: DevExercise1.MapRemoteDataSource)

  public required override init(`remoteDataSource`: DevExercise1.MapRemoteDataSource) { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `fetch`()

  public override func `fetch`() -> [AGSFeatureLayer] { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [AGSFeatureLayer], [AGSFeatureLayer]> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(MapRepositoryImpl.self).initialize(…)`.
public func mock(_ type: DevExercise1.MapRepositoryImpl.Type, file: StaticString = #file, line: UInt = #line) -> MapRepositoryImplMock.InitializerProxy.Type {
  return MapRepositoryImplMock.InitializerProxy.self
}

// MARK: - Mocked MapRepository

public final class MapRepositoryMock: DevExercise1.MapRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`()

  public func `fetch`() -> [AGSFeatureLayer] { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [AGSFeatureLayer], [AGSFeatureLayer]> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `MapRepository`.
public func mock(_ type: DevExercise1.MapRepository.Protocol, file: StaticString = #file, line: UInt = #line) -> MapRepositoryMock {
  return MapRepositoryMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked MapViewController

public final class MapViewControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'MapViewController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.MapViewController.Type, file: StaticString = #file, line: UInt = #line) -> MapViewControllerMock {
  fatalError()
}

// MARK: - Mocked MapViewModelInput

public final class MapViewModelInputMock: DevExercise1.MapViewModelInput, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `licenseMap`()

  public func `licenseMap`() throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `licenseMap`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `MapViewModelInput`.
public func mock(_ type: DevExercise1.MapViewModelInput.Protocol, file: StaticString = #file, line: UInt = #line) -> MapViewModelInputMock {
  return MapViewModelInputMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked MapViewModel

public final class MapViewModelMock: DevExercise1.MapViewModel, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`repository`: DevExercise1.MapRepository, __file: StaticString = #file, __line: UInt = #line) -> MapViewModelMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked `licenseMap`()

  public override func `licenseMap`() throws -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `licenseMap`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `retrieveFeatureLayers`(`completion`: @escaping ([AGSFeatureLayer]) -> Void)

  public override func `retrieveFeatureLayers`(`completion`: @escaping ([AGSFeatureLayer]) -> Void) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `retrieveFeatureLayers`(`completion`: @escaping @autoclosure () -> ([AGSFeatureLayer]) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping ([AGSFeatureLayer]) -> Void) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`repository`: DevExercise1.MapRepository)

  public required override init(`repository`: DevExercise1.MapRepository) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(MapViewModel.self).initialize(…)`.
public func mock(_ type: DevExercise1.MapViewModel.Type, file: StaticString = #file, line: UInt = #line) -> MapViewModelMock.InitializerProxy.Type {
  return MapViewModelMock.InitializerProxy.self
}

// MARK: - Mocked Reachability

public final class ReachabilityMock: DevExercise1.Reachability, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`reachabilityRef`: SCNetworkReachability, __file: StaticString = #file, __line: UInt = #line) -> ReachabilityMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked currentReachabilityStatus

  override public var `currentReachabilityStatus`: DevExercise1.Reachability.NetworkStatus { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCurrentReachabilityStatus() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> DevExercise1.Reachability.NetworkStatus, DevExercise1.Reachability.NetworkStatus> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked currentReachabilityString

  override public var `currentReachabilityString`: String { get { fatalError("See 'Thunk Stubs' in the README") } }

  public func getCurrentReachabilityString() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked reachableOnWWAN

  override public var `reachableOnWWAN`: Bool { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getReachableOnWWAN() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Bool, Bool> { fatalError("See 'Thunk Stubs' in the README") }

  public func setReachableOnWWAN(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (Bool) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked whenReachable

  override public var `whenReachable`: ReachabilityMock.NetworkReachable? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getWhenReachable() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> ReachabilityMock.NetworkReachable?, ReachabilityMock.NetworkReachable?> { fatalError("See 'Thunk Stubs' in the README") }

  public func setWhenReachable(_ newValue: @escaping @autoclosure () -> ReachabilityMock.NetworkReachable?) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (ReachabilityMock.NetworkReachable?) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked whenUnreachable

  override public var `whenUnreachable`: ReachabilityMock.NetworkUnreachable? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getWhenUnreachable() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> ReachabilityMock.NetworkUnreachable?, ReachabilityMock.NetworkUnreachable?> { fatalError("See 'Thunk Stubs' in the README") }

  public func setWhenUnreachable(_ newValue: @escaping @autoclosure () -> ReachabilityMock.NetworkUnreachable?) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (ReachabilityMock.NetworkUnreachable?) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`reachabilityRef`: SCNetworkReachability)

  public required init(`reachabilityRef`: SCNetworkReachability) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(Reachability.self).initialize(…)`.
public func mock(_ type: DevExercise1.Reachability.Type, file: StaticString = #file, line: UInt = #line) -> ReachabilityMock.InitializerProxy.Type {
  return ReachabilityMock.InitializerProxy.self
}

// MARK: - Mocked SceneDelegate

public final class SceneDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'SceneDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.SceneDelegate.Type, file: StaticString = #file, line: UInt = #line) -> SceneDelegateMock {
  fatalError()
}

// MARK: - Mocked SignOutController

public final class SignOutControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }
}

@available(*, unavailable, message: "'SignOutController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: DevExercise1.SignOutController.Type, file: StaticString = #file, line: UInt = #line) -> SignOutControllerMock {
  fatalError()
}

// MARK: - Mocked SignOut

public final class SignOutMock: DevExercise1.SignOut, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `signOut`()

  public func `signOut`() -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `signOut`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `SignOut`.
public func mock(_ type: DevExercise1.SignOut.Protocol, file: StaticString = #file, line: UInt = #line) -> SignOutMock {
  return SignOutMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked UserLocalImpl

public final class UserLocalImplMock: DevExercise1.UserLocalImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `rememberUser`()

  public override func `rememberUser`() -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `rememberUser`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `signOut`()

  public override func `signOut`() -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `signOut`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `UserLocalImpl`.
public func mock(_ type: DevExercise1.UserLocalImpl.Type, file: StaticString = #file, line: UInt = #line) -> UserLocalImplMock {
  return UserLocalImplMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked UserLocal

public final class UserLocalMock: DevExercise1.UserLocal, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `rememberUser`()

  public func `rememberUser`() -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `rememberUser`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `signOut`()

  public func `signOut`() -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `signOut`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `UserLocal`.
public func mock(_ type: DevExercise1.UserLocal.Protocol, file: StaticString = #file, line: UInt = #line) -> UserLocalMock {
  return UserLocalMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked UserRemoteImpl

public final class UserRemoteImplMock: DevExercise1.UserRemoteImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `arcGISSignIn`(`credential`: AGSCredential)

  public override func `arcGISSignIn`(`credential`: AGSCredential) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `arcGISSignIn`(`credential`: @escaping @autoclosure () -> AGSCredential) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (AGSCredential) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `UserRemoteImpl`.
public func mock(_ type: DevExercise1.UserRemoteImpl.Type, file: StaticString = #file, line: UInt = #line) -> UserRemoteImplMock {
  return UserRemoteImplMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked UserRemote

public final class UserRemoteMock: DevExercise1.UserRemote, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `arcGISSignIn`(`credential`: AGSCredential)

  public func `arcGISSignIn`(`credential`: AGSCredential) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `arcGISSignIn`(`credential`: @escaping @autoclosure () -> AGSCredential) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (AGSCredential) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `UserRemote`.
public func mock(_ type: DevExercise1.UserRemote.Protocol, file: StaticString = #file, line: UInt = #line) -> UserRemoteMock {
  return UserRemoteMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked UserRepositoryImpl

public final class UserRepositoryImplMock: DevExercise1.UserRepositoryImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`userRemote`: DevExercise1.UserRemote, `userLocal`: DevExercise1.UserLocal, __file: StaticString = #file, __line: UInt = #line) -> UserRepositoryImplMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked `handleSignOut`()

  public override func `handleSignOut`() -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `handleSignOut`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`userRemote`: DevExercise1.UserRemote, `userLocal`: DevExercise1.UserLocal)

  public required override init(`userRemote`: DevExercise1.UserRemote, `userLocal`: DevExercise1.UserLocal) { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `handleLogin`(`username`: String, `password`: String)

  public override func `handleLogin`(`username`: String, `password`: String) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `handleLogin`(`username`: @escaping @autoclosure () -> String, `password`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, String) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(UserRepositoryImpl.self).initialize(…)`.
public func mock(_ type: DevExercise1.UserRepositoryImpl.Type, file: StaticString = #file, line: UInt = #line) -> UserRepositoryImplMock.InitializerProxy.Type {
  return UserRepositoryImplMock.InitializerProxy.self
}

// MARK: - Mocked UserRepository

public final class UserRepositoryMock: DevExercise1.UserRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.0", "module_name": "DevExercise1"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `handleSignOut`()

  public func `handleSignOut`() -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `handleSignOut`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked `handleLogin`(`username`: String, `password`: String)

  public func `handleLogin`(`username`: String, `password`: String) -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `handleLogin`(`username`: @escaping @autoclosure () -> String, `password`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, String) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns a concrete mock of `UserRepository`.
public func mock(_ type: DevExercise1.UserRepository.Protocol, file: StaticString = #file, line: UInt = #line) -> UserRepositoryMock {
  return UserRepositoryMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}
